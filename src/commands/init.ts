import * as fs from "fs";
import * as path from "path";

// Function to generate config with custom base directory
function createDefaultConfig(baseDir: string): string {
  return `schema: 1
partialsDir: ${baseDir}/agent-partials
templatesDir: ${baseDir}/agent-templates
output: 
  - agent: gemini
    template: gemini.md.tmpl
    outFile: GEMINI.md
`;
}

const DEFAULT_TEMPLATE = `
<!-- Generated by agent-context. Do not edit directly. -->

{{> overview }}
`;

const DEFAULT_PARTIAL = `
# Project Overview

This is the project overview.
`;

// Helper function to validate directory names
function isValidDirName(name: string): boolean {
  if (!name || name.trim() === "") return false;

  // Check for invalid characters (platform-specific)
  const invalidChars = process.platform === "win32" ? /[<>:"/\\|?*]/ : /\//;

  if (invalidChars.test(name)) return false;

  // Check for reserved names on Windows
  if (process.platform === "win32") {
    const reservedNames = [
      "CON",
      "PRN",
      "AUX",
      "NUL",
      "COM1",
      "COM2",
      "COM3",
      "COM4",
      "COM5",
      "COM6",
      "COM7",
      "COM8",
      "COM9",
      "LPT1",
      "LPT2",
      "LPT3",
      "LPT4",
      "LPT5",
      "LPT6",
      "LPT7",
      "LPT8",
      "LPT9",
    ];
    if (reservedNames.includes(name.toUpperCase())) return false;
  }

  // Check for . and ..
  if (name === "." || name === "..") return false;

  return true;
}

// Helper function to validate paths and prevent path traversal
function isValidPath(targetPath: string, rootDir: string): boolean {
  try {
    // Normalize and resolve the path
    const normalizedTarget = path.resolve(targetPath);
    const normalizedRoot = path.resolve(rootDir);

    // For relative paths, ensure they don't go above the root directory
    // For absolute paths, we'll allow them but warn about security
    if (!path.isAbsolute(targetPath)) {
      // Check if the resolved path is within or at the same level as root
      const relativePath = path.relative(normalizedRoot, normalizedTarget);
      if (relativePath.startsWith("..")) {
        return false; // Path traversal detected
      }
    }

    return true;
  } catch (error) {
    return false;
  }
}

export async function initCommand() {
  const rootDir = process.cwd();

  // Prompt user for target directory
  const readline = require("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  // Handle graceful interruption
  rl.on("SIGINT", () => {
    console.log("\nOperation cancelled by user.");
    rl.close();
    process.exit(0);
  });

  console.log(
    "\nWhere would you like to initialize the agent context project?"
  );
  console.log("1. Current directory");
  console.log("2. Create new directory");
  console.log("3. Choose existing directory");

  // Input validation loop for choice
  let choice: string;
  do {
    choice = await new Promise<string>((resolve) => {
      rl.question("Enter your choice (1, 2, or 3): ", (answer: string) => {
        resolve(answer.trim());
      });
    });
    if (!["1", "2", "3"].includes(choice)) {
      console.log("Invalid choice. Please enter 1, 2, or 3.");
    }
  } while (!["1", "2", "3"].includes(choice));

  let targetDir = rootDir;

  if (choice === "2") {
    let dirName: string;
    do {
      dirName = await new Promise<string>((resolve) => {
        rl.question("Enter new directory name: ", (answer: string) => {
          resolve(answer.trim());
        });
      });
      if (!dirName) {
        console.log(
          "Directory name cannot be empty. Please enter a valid name."
        );
      } else if (!isValidDirName(dirName)) {
        console.log(
          "Directory name contains invalid characters. Please use only letters, numbers, hyphens, and underscores."
        );
        dirName = ""; // Reset to trigger loop again
      }
    } while (!dirName);

    targetDir = path.join(rootDir, dirName);
    if (!fs.existsSync(targetDir)) {
      try {
        fs.mkdirSync(targetDir, { recursive: true });
        console.log(`Created directory: ${targetDir}`);
      } catch (error) {
        console.error(
          `Failed to create directory: ${
            error instanceof Error ? error.message : "Unknown error"
          }`
        );
        rl.close();
        return;
      }
    }
  } else if (choice === "3") {
    let dirPath: string;
    do {
      dirPath = await new Promise<string>((resolve) => {
        rl.question("Enter directory path: ", (answer: string) => {
          resolve(answer.trim());
        });
      });
      if (!dirPath) {
        console.log(
          "Directory path cannot be empty. Please enter a valid path."
        );
      }
    } while (!dirPath);

    // Resolve the path
    targetDir = path.isAbsolute(dirPath)
      ? dirPath
      : path.join(rootDir, dirPath);

    // Validate the path
    if (!isValidPath(targetDir, rootDir)) {
      console.error(
        "Invalid path: Path traversal detected or path is outside safe boundaries."
      );
      rl.close();
      return;
    }

    if (!fs.existsSync(targetDir)) {
      console.error(`Directory does not exist: ${targetDir}`);
      rl.close();
      return;
    }

    if (!fs.statSync(targetDir).isDirectory()) {
      console.error(`Path is not a directory: ${targetDir}`);
      rl.close();
      return;
    }
  }

  rl.close();

  // Check write permissions
  try {
    fs.accessSync(targetDir, fs.constants.W_OK);
  } catch (error) {
    console.error(`No write permission to directory: ${targetDir}`);
    return;
  }

  console.log(`Using directory: ${targetDir}\n`);

  // Prompt for base directory name
  const readline2 = require("readline");
  const rl2 = readline2.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  // Handle graceful interruption for second readline
  rl2.on("SIGINT", () => {
    console.log("\nOperation cancelled by user.");
    rl2.close();
    process.exit(0);
  });

  console.log("Choose the base directory name for agent files:");
  console.log(
    '(This will create subdirectories like "<base>/agent-partials" and "<base>/agent-templates")'
  );

  let baseDir: string;
  do {
    baseDir = await new Promise<string>((resolve) => {
      rl2.question(
        "Enter base directory name (default: docs): ",
        (answer: string) => {
          const trimmed = answer.trim();
          resolve(trimmed || "docs"); // Use "docs" as default if empty
        }
      );
    });

    if (!isValidDirName(baseDir)) {
      console.log(
        "Directory name contains invalid characters. Please use only letters, numbers, hyphens, and underscores."
      );
      baseDir = ""; // Reset to trigger loop again
    }
  } while (!baseDir);

  rl2.close();
  console.log(`Using base directory: ${baseDir}\n`);

  // Update paths to use target directory and chosen base directory
  const partialsDir = path.join(targetDir, baseDir, "agent-partials");
  const templatesDir = path.join(targetDir, baseDir, "agent-templates");

  // Create config file
  const configPath = path.join(targetDir, ".agent-instructions.yaml");
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, createDefaultConfig(baseDir));
    console.log(`Created config file: ${configPath}`);
  } else {
    console.warn(`Config file already exists: ${configPath}`);
  }

  // Create partials directory and file
  if (!fs.existsSync(partialsDir)) {
    fs.mkdirSync(partialsDir, { recursive: true });
  }
  const partialPath = path.join(partialsDir, "overview.md");
  if (!fs.existsSync(partialPath)) {
    fs.writeFileSync(partialPath, DEFAULT_PARTIAL);
    console.log(`Created partial file: ${partialPath}`);
  } else {
    console.warn(`Partial file already exists: ${partialPath}`);
  }

  // Create templates directory and file
  if (!fs.existsSync(templatesDir)) {
    fs.mkdirSync(templatesDir, { recursive: true });
  }
  const templatePath = path.join(templatesDir, "gemini.md.tmpl");
  if (!fs.existsSync(templatePath)) {
    fs.writeFileSync(templatePath, DEFAULT_TEMPLATE);
    console.log(`Created template file: ${templatePath}`);
  } else {
    console.warn(`Template file already exists: ${templatePath}`);
  }

  console.log("\nProject initialized successfully!");
}
